// Code generated by goagen v1.2.0-dirty, DO NOT EDIT.
//
// API "antevent": analysis Resource Client
//
// Command:
// $ goagen
// --design=github.com/yinbaoqiang/goadame/design
// --out=$(GOPATH)/src/github.com/yinbaoqiang/goadame
// --version=v1.2.0-dirty

package client

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// HookAnalysisPath computes a request path to the hook action of analysis.
func HookAnalysisPath(eid string) string {
	param0 := eid

	return fmt.Sprintf("/v1/admin/event/analysis/hook/%s", param0)
}

// 事件回调执行情况
func (c *Client) HookAnalysis(ctx context.Context, path string, action *int) (*http.Response, error) {
	req, err := c.NewHookAnalysisRequest(ctx, path, action)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewHookAnalysisRequest create the request corresponding to the hook action endpoint of the analysis resource.
func (c *Client) NewHookAnalysisRequest(ctx context.Context, path string, action *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if action != nil {
		tmp9 := strconv.Itoa(*action)
		values.Set("action", tmp9)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ListAnalysisPath computes a request path to the list action of analysis.
func ListAnalysisPath() string {

	return fmt.Sprintf("/v1/admin/event/analysis")
}

// 事件发生历史
func (c *Client) ListAnalysis(ctx context.Context, path string, action *string, count *int, etype *string, from *string, page *int) (*http.Response, error) {
	req, err := c.NewListAnalysisRequest(ctx, path, action, count, etype, from, page)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListAnalysisRequest create the request corresponding to the list action endpoint of the analysis resource.
func (c *Client) NewListAnalysisRequest(ctx context.Context, path string, action *string, count *int, etype *string, from *string, page *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if action != nil {
		values.Set("action", *action)
	}
	if count != nil {
		tmp10 := strconv.Itoa(*count)
		values.Set("count", tmp10)
	}
	if etype != nil {
		values.Set("etype", *etype)
	}
	if from != nil {
		values.Set("from", *from)
	}
	if page != nil {
		tmp11 := strconv.Itoa(*page)
		values.Set("page", tmp11)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}
